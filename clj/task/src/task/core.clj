(ns task.core
  (:use [clj-sql.core :as sql :exclude (do-insert insert-record)])
  (:use [task.db])
  (:use [clojure.string :as s :only (lower-case upper-case)]))

;; copies of private methods from clj-sql.core due to problem with generated keys
(defn- join 
  "Joins the items in the given collection into a single string separated
   with the string separator."
  [separator col]
  (apply str (interpose separator col)))

(defn- sql-for-insert 
  "Converts a table identifier (keyword or string) and a hash identifying
   a record into an sql insert statement compatible with prepareStatement
    Returns [sql values-to-insert]"
  [table record]
  (let [table-name (quote-name table)
        columns (map quote-name (keys record))
        values (vals record)
        n (count columns)
        template (join "," (replicate n "?"))
        column-names (join "," columns)
        sql (format "insert into %s (%s) values (%s)"
                    table-name column-names template)]
    [sql values]))

;; updated to specify prepared statement should return generated keys
(defn do-insert 
  "Executes arbitary sql containing a single insert 
   and returns the autogenerated id of an inserted record if available.

     (do-insert \"insert into employees (name) values (?)\" [\"fred\"])"
  [sql param-group]
  (with-open [statement (.prepareStatement (connection) sql java.sql.Statement/RETURN_GENERATED_KEYS)]
    (doseq [[index value] (map vector (iterate inc 1) param-group)]
      (.setObject statement index value))
    (if (< 0 (.executeUpdate statement))
        (with-open [rs (.getGeneratedKeys statement)]
          (if-not (nil? rs)
            (-> rs resultset-seq first vals first))))))

;; needed to rebind updated do-insert
(defn insert-record 
  "Equivalent of clojure.contrib.sql/insert-records that only inserts a single
   record but returns the autogenerated id of that record if available."
  [table record]
  (let [[sql param-group] (sql-for-insert table record)]
    (do-insert sql param-group)))

;; real generic methods start here...

(defn get-by-id 
  ([t id] (get-by-id t id identity))
  ([t id f] (get-by-id t id f :id))
  ([t id f idk] ;; need to handle zero / ambiguous rows
    (sql/with-connection db
      (sql/with-query-results rows
        [(str "select * from " (name t) " where " (name idk) " = ?") id]
        (f (first rows))))))

(defn get-all 
  ([t] (get-all t doall))
  ([t f] 
    (sql/with-connection db
      (sql/with-query-results rows
        [(str "select * from " (name t))]
        (f rows)))))

(defn add-record [t r]
  (sql/with-connection db
    (insert-record t r)))

;; (defn- to-struct [r] (apply hash-map (flatten (map (fn [[k v]] [(s/upper-case (name k)) v]) r))))
;; Thanx to Baishampayan Ghose for this simpler version:
(defn- to-struct [r] (into {} (for [[k v] r] [(s/upper-case (name k)) v])))

;; (defn- to-rec [m] (apply hash-map (flatten (map (fn [[k v]] [(keyword (s/lower-case k)) v]) m))))
(defn- to-rec [m] (into {} (for [[k v] m] [(keyword (s/lower-case k)) v])))

;; task-specific methods

(defn add-task [task-name]
  (add-record :task {:name task-name}))

(defn get-all-tasks []
  (map to-struct (get-all :task)))

(defn get-task-by-id [id]
  (to-struct (get-by-id :task id)))